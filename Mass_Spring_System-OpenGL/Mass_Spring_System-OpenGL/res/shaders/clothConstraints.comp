#version 460

#define MAX_SPHERES 5

//Worksize
layout ( local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

struct Vertex {
    vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 normal;
	vec4 oldPos;
	vec4 pinned;
};

layout ( std430, binding = 0 ) buffer VertexBufferIn {
	Vertex verticesIn[];
};
layout ( std430, binding = 1 ) buffer VertexBufferOut {
	Vertex verticesOut[];
};

uniform float restLenHV;
uniform float restLenDiagonal;

uniform vec4 gridDims;
uniform float deltaTime;

struct Sphere {
	vec4 sphereCenter;
	float sphereRadius;
	bool sphereActive;
};
uniform Sphere spheres[MAX_SPHERES];

bool IsPinned (uint linearIdx) {
	return verticesIn[linearIdx].pinned.x >= 0.5;
}

vec3 ApplyConstraints (uint myIndex, uint otherIndex, float restLen) 
{
	vec3 position = verticesIn[myIndex].pos.xyz;
	vec3 otherPosition = verticesIn[otherIndex].pos.xyz;

	vec3 vectorToOther = otherPosition - position;
	float distanceToOther = length(vectorToOther);

	float maxDistance = restLen * 1.05;

	vec3 correction = vec3(0,0,0);
	float diff = distanceToOther - maxDistance;

	if (diff > 0) 
	{
		correction = normalize(vectorToOther) * diff * 0.5;

		correction = (IsPinned(otherIndex)) ? 
			correction * 2 :
			correction;		
	}

	return correction;
}

vec3 ComputeDistanceCorrection (uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) 
{
	vec3 totalCorrection = vec3(0,0,0);


	// Bend Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Down
	totalCorrection = (globalIdx.y > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;
		
	// Bend Spring - Left
	totalCorrection = (globalIdx.x > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2, restLenHV * 2) :
		totalCorrection;

	// Structure Spring - Down
	totalCorrection = (globalIdx.y > 0) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx - particleGridDims.x, restLenHV)) :
		totalCorrection;

	// Structure Spring - Left
	totalCorrection = (globalIdx.x > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 1, restLenHV) :
		totalCorrection;


	// Structure Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + 1, restLenHV)) :
		totalCorrection;

	// Structure Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 1) ? 
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + particleGridDims.x, restLenHV)) :
		totalCorrection;

	// Shear Spring - Upper-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Upper-Right
	totalCorrection = ((globalIdx.x < particleGridDims.x - 1) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y > 0)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) && (globalIdx.y > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	return totalCorrection;
}

vec3 ComputeSelfCollision(uint linearIdx, uvec3 particleGridDims, float restLen) {
	vec3 correction = vec3(0,0,0);
	uint size = particleGridDims.x * particleGridDims.y;
	float epsilon = restLen;

	for (int i = 0; i < size; i++) 
	{
		//if (i == linearIdx) {
		//	continue;
		//}

		vec3 dir = verticesIn[i].pos.xyz - verticesIn[linearIdx].pos.xyz;
		float dist = length(dir);
		vec3 norm = -normalize(dir);
		float correctionMult;
		vec3 currentCorrection = vec3(0,0,0);
		correctionMult = (IsPinned(i)) ? 
							1 :
							0.5;
		currentCorrection = (dist < epsilon && i != linearIdx) ?
								currentCorrection + norm * (epsilon - dist) * correctionMult :
								currentCorrection; 

		correction += currentCorrection;
	}

	return correction;
}

void UpdateNormals(uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) {
	vec3 position = verticesIn[linearIdx].pos.xyz;

	//Calculate normal
	vec3 normal = vec3(0.0);
	vec3 a, b, c;

	if (globalIdx.y > 0) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx - 1].pos.xyz - position;						//Left
			b = verticesIn[linearIdx - particleGridDims.x - 1].pos.xyz - position;  //Lower left
			c = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;		//Bottom
			normal += cross(a, b) + cross(b, c);
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;		//Bottom
			b = verticesIn[linearIdx - particleGridDims.x + 1].pos.xyz - position;  //Bottom right
			c = verticesIn[linearIdx + 1].pos.xyz - position;						//Right
			normal += cross(a, b) + cross(b, c);
		}
	}

	if (globalIdx.y < particleGridDims.y - 1) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;		//Top
			b = verticesIn[linearIdx + particleGridDims.x - 1].pos.xyz - position;  //Top left
			c = verticesIn[linearIdx - 1].pos.xyz - position;						//Left
			normal += cross(a, b) + cross(b, c);
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx + 1].pos.xyz - position;						//Right
			b = verticesIn[linearIdx + particleGridDims.x + 1].pos.xyz - position;	//Top right
			c = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;		//Top
			normal += cross(a, b) + cross(b, c);
		}
	}

	verticesOut[linearIdx].normal = vec4(normalize(normal), 0.0f);
}

void UpdateData(vec3 position, vec3 oldPosition, vec3 velocity, 
				uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) {
	//Update pos on buffer
	verticesOut[linearIdx].pos = vec4(position, 1.0);
	verticesOut[linearIdx].oldPos = vec4(oldPosition, 1.0);
	verticesOut[linearIdx].vel = vec4(velocity, 0.0);

	UpdateNormals(linearIdx, particleGridDims, globalIdx);
}

void main() 
{
	uvec3 particleGridDims = uvec3(gridDims.x, gridDims.y, 1);
	uvec3 globalIdx = gl_GlobalInvocationID; 
	uint linearIdx = globalIdx.x + (globalIdx.y * particleGridDims.x);
	
	// Safety check
	if (globalIdx.x >= particleGridDims.x || globalIdx.y >= particleGridDims.y) 
		return;

	// Keep pinned particles fixed
	if (IsPinned(linearIdx)) {
		verticesOut[linearIdx].pos = verticesIn[linearIdx].pos;
		verticesOut[linearIdx].oldPos = verticesIn[linearIdx].oldPos;
		verticesOut[linearIdx].vel = vec4(0.0);
		return;
	}

	vec3 position = verticesIn[linearIdx].pos.xyz;
	vec3 oldPosition = verticesIn[linearIdx].oldPos.xyz;
	vec3 velocity = verticesIn[linearIdx].vel.xyz;

	vec3 correctedPosition = position;
	vec3 correctedVelocity = vec3(0,0,0);

	// Distance constraints
	float correctionDamp = .25f;

	vec3 distCorrection = vec3(0,0,0);
	distCorrection = ComputeDistanceCorrection(linearIdx, particleGridDims, globalIdx) * correctionDamp;

	// Self collisions
	vec3 selfCollCorrection = vec3(0,0,0);
	selfCollCorrection = ComputeSelfCollision(linearIdx, particleGridDims, restLenHV * .8);

	
	correctedPosition += distCorrection;
	correctedPosition += selfCollCorrection;
	
	correctedVelocity = (correctedPosition - oldPosition) / deltaTime;
	correctedVelocity = (length(correctedVelocity) >= 50000) ? correctedVelocity * 0.0001 : correctedVelocity;

	//COLLISION DETECTION
	for (int i = 0; i < MAX_SPHERES; i++)
	{
		//bool currSphereActive = sphereActive[i];
		if (spheres[i].sphereActive)
		{
			//vec3 currSpherePos = sphereCenter[i].xyz;
			//float currSphereRadius = sphereRadius[i];

			vec3 sphereDist = correctedPosition - spheres[i].sphereCenter.xyz;

			if (length(sphereDist) < spheres[i].sphereRadius + restLenHV * 0.33) 
			{
				// If the particle is inside the sphere, push it to the outer radius
				correctedPosition = spheres[i].sphereCenter.xyz + normalize(sphereDist) 
									* (spheres[i].sphereRadius + restLenHV * 0.33);
				// Cancel out velocity
				correctedVelocity *= 0.95f;
			}
		}
	}
    
	UpdateData(correctedPosition, oldPosition, correctedVelocity, linearIdx, particleGridDims, globalIdx);
}