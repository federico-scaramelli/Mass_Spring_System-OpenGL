#version 460

#define MAX_SPHERES 10

//Worksize
layout ( local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

struct Vertex {
    vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 normal;
	vec4 oldPos;
	vec4 pinned;
};

layout ( std430, binding = 0 ) buffer VertexBufferIn {
	Vertex verticesIn[];
};
layout ( std430, binding = 1 ) buffer VertexBufferOut {
	Vertex verticesOut[];
};

uniform float restLenHV;
uniform float restLenDiagonal;

uniform vec4 gridDims;
uniform float deltaTime;

struct Sphere {
	vec4 sphereCenter;
	float sphereRadius;
	bool sphereActive;
};
uniform uint sphereCount;
uniform Sphere spheres[MAX_SPHERES];

struct ConstraintParams {
	float correctionDumping;
	float constraintDistanceMult;
	float selfCollisionDistanceMult;
	float sphereRepulsionDistMult;
	float sphereRepulsionDamping;
};
uniform ConstraintParams constraintParams;


bool IsPinned (uint linearIdx) {
	return verticesIn[linearIdx].pinned.x >= 0.5;
}

vec3 ApplyConstraints (uint myIndex, uint otherIndex, float restLen) 
{
	vec3 position = verticesIn[myIndex].pos.xyz;
	vec3 otherPosition = verticesIn[otherIndex].pos.xyz;

	vec3 vectorToOther = otherPosition - position;
	float distanceToOther = length(vectorToOther);

	//float constraintDistanceMult = 1.1;
	float maxDistance = restLen * constraintParams.constraintDistanceMult;

	vec3 correction = vec3(0,0,0);
	float diff = distanceToOther - maxDistance;

	if (diff > 0) 
	{
		correction = normalize(vectorToOther) * diff * 0.5;

		correction = (IsPinned(otherIndex)) ? 
			correction * 2 :
			correction;		
	}

	return correction;
}

vec3 ComputeDistanceCorrection (uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) 
{
	vec3 totalCorrection = vec3(0,0,0);

	// Bend Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Down
	totalCorrection = (globalIdx.y > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;
		
	// Bend Spring - Left
	totalCorrection = (globalIdx.x > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2, restLenHV * 2) :
		totalCorrection;

	// Structure Spring - Down
	totalCorrection = (globalIdx.y > 0) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx - particleGridDims.x, restLenHV)) :
		totalCorrection;

	// Structure Spring - Left
	totalCorrection = (globalIdx.x > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 1, restLenHV) :
		totalCorrection;

	// Structure Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + 1, restLenHV)) :
		totalCorrection;

	// Structure Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 1) ? 
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + particleGridDims.x, restLenHV)) :
		totalCorrection;

	// Shear Spring - Upper-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Upper-Right
	totalCorrection = ((globalIdx.x < particleGridDims.x - 1) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y > 0)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) && (globalIdx.y > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	return totalCorrection;
}

vec3 ComputeSelfCollision(uint linearIdx, uvec3 particleGridDims, float radius) {
	vec3 correction = vec3(0,0,0);
	uint size = particleGridDims.x * particleGridDims.y;

	for (int i = 0; i < size; i++) 
	{
		if (i == linearIdx) {
			continue;
		}

		vec3 vectorToOther = verticesIn[i].pos.xyz - verticesIn[linearIdx].pos.xyz;
		float dist = length(vectorToOther);
		vec3 dirToOther = normalize(vectorToOther);

		float correctionMult;
		vec3 currentCorrection = vec3(0,0,0);

		correctionMult = (IsPinned(i)) ? 
							1 :
							0.5;

		float diff = dist - radius;
		currentCorrection = (diff < 0 && i != linearIdx) ?
								currentCorrection + dirToOther * diff * correctionMult:
								currentCorrection; 

		correction += currentCorrection;
	}

	return correction;
}

void UpdateNormals(uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) {
	vec3 position = verticesIn[linearIdx].pos.xyz;

	//Calculate normal
	vec3 normal = vec3(0.0);
	vec3 a, b, c;
	float sum=0;

	if (globalIdx.y > 0) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx - 1].pos.xyz - position;						//Left
			b = verticesIn[linearIdx - particleGridDims.x - 1].pos.xyz - position;  //Lower left
			c = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;		//Bottom
			normal += cross(a, b) + cross(b, c);

			sum+=2;
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;		//Bottom
			b = verticesIn[linearIdx - particleGridDims.x + 1].pos.xyz - position;  //Bottom right
			c = verticesIn[linearIdx + 1].pos.xyz - position;						//Right
			normal += cross(a, b) + cross(b, c);

			sum+=2;
		}
	}

	if (globalIdx.y < particleGridDims.y - 1) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;		//Top
			b = verticesIn[linearIdx + particleGridDims.x - 1].pos.xyz - position;  //Top left
			c = verticesIn[linearIdx - 1].pos.xyz - position;						//Left
			normal += cross(a, b) + cross(b, c);

			sum+=2;
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx + 1].pos.xyz - position;						//Right
			b = verticesIn[linearIdx + particleGridDims.x + 1].pos.xyz - position;	//Top right
			c = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;		//Top
			normal += cross(a, b) + cross(b, c);

			sum+=2;
		}
	}

	normal = (sum != 0) ? normal / sum : normal;

	verticesOut[linearIdx].normal = vec4(normalize(normal), 0.0f);
}

void UpdateData(vec3 position, vec3 oldPosition, vec3 velocity, 
				uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) {
	//Update pos on buffer
	verticesOut[linearIdx].pos = vec4(position, 1.0);
	verticesOut[linearIdx].oldPos = vec4(oldPosition, 1.0);
	verticesOut[linearIdx].vel = vec4(velocity, 0.0);

	UpdateNormals(linearIdx, particleGridDims, globalIdx);
}

void main() 
{
	uvec3 particleGridDims = uvec3(gridDims.x, gridDims.y, 1);
	uvec3 globalIdx = gl_GlobalInvocationID; 
	uint linearIdx = globalIdx.x + (globalIdx.y * particleGridDims.x);
	
	// Safety check
	if (globalIdx.x >= particleGridDims.x || globalIdx.y >= particleGridDims.y) 
		return;

	// Keep pinned particles fixed
	if (IsPinned(linearIdx)) {
		verticesOut[linearIdx].pos = verticesIn[linearIdx].pos;
		verticesOut[linearIdx].oldPos = verticesIn[linearIdx].oldPos;
		verticesOut[linearIdx].vel = vec4(0.0);
		return;
	}

	vec3 position = verticesIn[linearIdx].pos.xyz;
	vec3 oldPosition = verticesIn[linearIdx].oldPos.xyz;
	vec3 velocity = verticesIn[linearIdx].vel.xyz;

	vec3 correctedPosition = position;
	vec3 correctedVelocity = vec3(0,0,0);

	// Distance constraints
	//float correctionDamp = .25f;
	vec3 distCorrection = vec3(0,0,0);
	distCorrection = ComputeDistanceCorrection(linearIdx, particleGridDims, globalIdx) * constraintParams.correctionDumping;

	// Self collisions
	vec3 selfCollCorrection = vec3(0,0,0);
	//float selfCollisionDistMult = 0.8;
	float selfCollisionDistance = restLenHV * constraintParams.selfCollisionDistanceMult;
	selfCollCorrection = ComputeSelfCollision(linearIdx, particleGridDims, selfCollisionDistance);

	correctedPosition += distCorrection;
	correctedPosition += selfCollCorrection;
	
	correctedVelocity = (correctedPosition - oldPosition) / deltaTime;
	float maxVelocity = 10000;
	correctedVelocity = (length(correctedVelocity) >= maxVelocity) ? correctedVelocity * 0.0001 : correctedVelocity;

	//METTERE QUA IL DUMPING DELLA VELOCITA'

	//COLLISION DETECTION
	for (int i = 0; i < sphereCount; i++)
	{
		//bool currSphereActive = sphereActive[i];
		if (spheres[i].sphereActive)
		{
			//vec3 currSpherePos = sphereCenter[i].xyz;
			//float currSphereRadius = sphereRadius[i];

			vec3 sphereDist = correctedPosition - spheres[i].sphereCenter.xyz;

			if (length(sphereDist) < spheres[i].sphereRadius + restLenHV * constraintParams.sphereRepulsionDistMult) 
			{
				// If the particle is inside the sphere, push it to the outer radius
				correctedPosition = spheres[i].sphereCenter.xyz + normalize(sphereDist) 
									* (spheres[i].sphereRadius + restLenHV  * constraintParams.sphereRepulsionDistMult);
				// Cancel out velocity
				correctedVelocity *= constraintParams.sphereRepulsionDamping;
			}
		}
	}
    
	UpdateData(correctedPosition, oldPosition, correctedVelocity, linearIdx, particleGridDims, globalIdx);
}