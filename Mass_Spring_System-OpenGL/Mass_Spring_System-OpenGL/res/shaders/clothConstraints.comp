#version 460

//Worksize
layout ( local_size_x = 10, local_size_y = 10, local_size_z = 1 ) in;

struct Vertex {
    vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 normal;
	vec4 oldPos;
	vec4 pinned;
};

layout ( std430, binding = 1 ) buffer VertexBufferIn {
	Vertex verticesIn[];
};
layout ( std430, binding = 0 ) buffer VertexBufferOut {
	Vertex verticesOut[];
};

uniform float restLenHorizontal = 0.5;
uniform float restLenVertical = 0.5;
uniform float restLenDiagonal = 0.707;

//bool IsPinned (uint linearIdx) {
//	return verticesIn[linearIdx].pinned.x >= 0.5;
//}
//
//void ApplyConstraints (uint particle, uint other, float maxDistance) 
//{
//	vec3 position = verticesIn[particle].pos.xyz;
//	vec3 otherPosition = verticesIn[other].pos.xyz;
//
//	vec3 BtoAVector = position - otherPosition;
//	float BtoAMagnitude = length(BtoAVector);
//	
//	if (BtoAMagnitude > maxDistance) {
//		float diff = BtoAMagnitude - maxDistance;
//		vec3 correction = normalize(BtoAVector) * diff * 0.5f;
//
//		if (!IsPinned(particle) && !IsPinned(other)) {
//			verticesOut[particle].pos = vec4((position - correction), 1.0);
//			//verticesOut[other].pos = vec4((otherPosition + correction), 1.0);
//		}
//		else if (!IsPinned(particle)) {
//			verticesOut[particle].pos = vec4((position - (2.f * correction)), 1.0);
//		}
//		else {
//			//verticesOut[other].pos = vec4((otherPosition + (2.f * correction)), 1.0);
//		}
//	}
//}
//
//float random (vec2 st) {
//    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
//}
//
//vec3 ComputeElasticForce (uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx, vec3 position) 
//{
//	vec3 totalForce = vec3(0,0,0);
//
//	// NOTE: x = column; y = row;
//
//	// STRUCTURE - Horizonal / Vertical
//	// Structure Spring - Up
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx + particleGridDims.x].pos.xyz, restLenVertical)
//				  * int(globalIdx.y < particleGridDims.y - 1);
//	// Structure Spring - Down
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx - particleGridDims.x].pos.xyz, restLenVertical)
//				  * int(globalIdx.y > 0);
//	// Structure Spring - Left
//		totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx-1].pos.xyz, restLenHorizontal)
//				  * int(globalIdx.x > 0);
//	// Structure Spring - Right
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx + 1].pos.xyz, restLenHorizontal)
//				  * int(globalIdx.x < particleGridDims.x - 1);
//
//	// SHEAR - Diagonal
//	// Shear Spring - Upper-Left
//	totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx + particleGridDims.x - 1].pos.xyz, restLenDiagonal)
//				  * int((globalIdx.x > 0) && (globalIdx.y < particleGridDims.y - 1));
//	// Shear Spring - Lower-Left
//	totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx - particleGridDims.x - 1].pos.xyz, restLenDiagonal)
//				  * int((globalIdx.x > 0) && (globalIdx.y > 0));
//	// Shear Spring - Upper-Right
//	totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx + particleGridDims.x + 1].pos.xyz, restLenDiagonal)
//				  * int((globalIdx.x < particleGridDims.x - 1) && (globalIdx.y < particleGridDims.y - 1));
//	// Shear Spring - Lower-Right
//	totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx - particleGridDims.x + 1].pos.xyz, restLenDiagonal)
//				  * int((globalIdx.x < particleGridDims.x - 1) && (globalIdx.y > 0));
//
//	// BEND - Distance 2  Horizonal / Vertical 
//	// Bend Spring - Up
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx + 2 * particleGridDims.x].pos.xyz, restLenVertical * 2)
//				  * int(globalIdx.y < particleGridDims.y - 2);
//
//	// Bend Spring - Down
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx - 2 * particleGridDims.x].pos.xyz, restLenVertical * 2)
//				  * int(globalIdx.y > 1);
//		
//	// Bend Spring - Left
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx - 2].pos.xyz, restLenHorizontal * 2)
//				  * int(globalIdx.x > 1);
//	// Bend Spring - Right
//	totalForce += constShearMult * ElasticForce(position, verticesIn[linearIdx + 2].pos.xyz, restLenHorizontal * 2)
//				  * int(globalIdx.x < particleGridDims.x - 2);
//
//	return totalForce;
//}

void main() 
{
	uvec3 particleGridDims = gl_NumWorkGroups * gl_WorkGroupSize;
	uvec3 globalIdx = gl_GlobalInvocationID; 
	uint linearIdx = globalIdx.x + (globalIdx.y * particleGridDims.x);
	
	// Safety check
	if (linearIdx > particleGridDims.x * particleGridDims.y) 
		return;

	vec3 pos = verticesIn[linearIdx].pos.xyz;
	pos.y += .01f;
	verticesOut[linearIdx].pos = vec4(pos, 1);
	verticesOut[linearIdx].oldPos = verticesIn[linearIdx].oldPos;

	// Keep pinned particles fixed
//	if (IsPinned(linearIdx)) {
//		verticesOut[linearIdx].pos = verticesIn[linearIdx].pos;
//		verticesOut[linearIdx].vel = vec4(0.0);
//		return;
//	}
//	
//	vec3 totalForce = vec3(0,0,0);
//
//	vec3 position = verticesIn[linearIdx].pos.xyz;
//	vec3 oldPosition = verticesIn[linearIdx].oldPos.xyz;
//	vec3 velocity = verticesIn[linearIdx].vel.xyz;
//
//	totalForce += ComputeElasticForce(linearIdx, particleGridDims, globalIdx, position);
//	vec3 gravity = gravityAcceleration.xyz;
////	gravity.z *= random(vec2(totalForce.y, totalForce.y / 2));
////	gravity.z *= 20 / (globalIdx.y + 1);
//	vec3 gravityForce = gravity * particleMass;
//	totalForce += gravityForce;
//	vec3 acceleration = totalForce / particleMass;
//
//	VerletIntegrator(linearIdx, acceleration, position, oldPosition);

//	if (globalIdx.y < particleGridDims.y - 1) {
//		ApplyConstraints(linearIdx, linearIdx + particleGridDims.x, restLenVertical*2);
//		//totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx + particleGridDims.x].pos.xyz, restLenVertical);
//	} 

	// lower
//	if (globalIdx.y > 0) {
//		ApplyConstraints(linearIdx, linearIdx - particleGridDims.x, restLenVertical*2);
//		//totalForce += constShearMult*ElasticForce(position, verticesIn[linearIdx - particleGridDims.x].pos.xyz, restLenVertical);
//	}
}