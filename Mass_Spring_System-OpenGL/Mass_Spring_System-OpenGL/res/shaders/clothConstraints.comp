#version 460

//Worksize
layout ( local_size_x = 16, local_size_y = 16, local_size_z = 1 ) in;

struct Vertex {
    vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 normal;
	vec4 oldPos;
	vec4 pinned;
};

layout ( std430, binding = 0 ) buffer VertexBufferIn {
	Vertex verticesIn[];
};
layout ( std430, binding = 1 ) buffer VertexBufferOut {
	Vertex verticesOut[];
};

uniform float restLenHV;
uniform float restLenDiagonal;

uniform vec4 gridDims;
uniform float deltaTime;

bool IsPinned (uint linearIdx) {
	return verticesIn[linearIdx].pinned.x >= 0.5;
}

vec3 ApplyConstraints (uint myIndex, uint otherIndex, float restLen) 
{
	vec3 position = verticesIn[myIndex].pos.xyz;
	vec3 otherPosition = verticesIn[otherIndex].pos.xyz;

	vec3 vectorToOther = otherPosition - position;
	float distanceToOther = length(vectorToOther);

	float maxDistance = restLen * 1.05;

	vec3 correction = vec3(0,0,0);
	float diff = distanceToOther - maxDistance;

	if (diff > 0) 
	{
		correction = normalize(vectorToOther) * diff * 0.5;

		correction = (IsPinned(otherIndex)) ? 
			correction * 2 :
			correction;		
	}

	return correction;
}

vec3 ComputeTotalCorrection (uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) 
{
	vec3 totalCorrection = vec3(0,0,0);


	// Bend Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Down
	totalCorrection = (globalIdx.y > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2 * particleGridDims.x, restLenHV * 2) :
		totalCorrection;
		
	// Bend Spring - Left
	totalCorrection = (globalIdx.x > 1) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 2, restLenHV * 2) :
		totalCorrection;

	// Bend Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 2) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + 2, restLenHV * 2) :
		totalCorrection;

	// Structure Spring - Down
	totalCorrection = (globalIdx.y > 0) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx - particleGridDims.x, restLenHV)) :
		totalCorrection;

	// Structure Spring - Left
	totalCorrection = (globalIdx.x > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - 1, restLenHV) :
		totalCorrection;


	// Structure Spring - Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) ?
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + 1, restLenHV)) :
		totalCorrection;

	// Structure Spring - Up
	totalCorrection = (globalIdx.y < particleGridDims.y - 1) ? 
		totalCorrection + (ApplyConstraints(linearIdx, linearIdx + particleGridDims.x, restLenHV)) :
		totalCorrection;


	// Shear Spring - Upper-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Upper-Right
	totalCorrection = ((globalIdx.x < particleGridDims.x - 1) && (globalIdx.y < particleGridDims.y - 1)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx + particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Left
	totalCorrection = ((globalIdx.x > 0) && (globalIdx.y > 0)) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x - 1, restLenDiagonal) :
		totalCorrection;

	// Shear Spring - Lower-Right
	totalCorrection = (globalIdx.x < particleGridDims.x - 1) && (globalIdx.y > 0) ?
		totalCorrection + ApplyConstraints(linearIdx, linearIdx - particleGridDims.x + 1, restLenDiagonal) :
		totalCorrection;

	return totalCorrection;
}

vec3 ComputeSelfCollision(uint linearIdx, uvec3 particleGridDims, float restLen) {
	vec3 correction = vec3(0,0,0);
	uint size = particleGridDims.x * particleGridDims.y;
	float epsilon = restLen * .8f;

	for (int i = 0; i < size; i++) 
	{
//		if (i == linearIdx) {
//			continue;
//		}

		vec3 dir = verticesIn[i].pos.xyz - verticesIn[linearIdx].pos.xyz;
		float dist = length(dir);
		vec3 norm = -normalize(dir);
		float correctionMult;
		vec3 currentCorrection = vec3(0,0,0);
		correctionMult = (IsPinned(i)) ? 
							1 :
							0.5;
		currentCorrection = (dist < epsilon && i != linearIdx) ?
								currentCorrection + norm * (epsilon - dist) * correctionMult :
								currentCorrection; 

		correction += currentCorrection;
	}

	return correction;
}

void UpdateNormals(uint linearIdx, uvec3 particleGridDims, uvec3 globalIdx) {
	vec3 position = verticesIn[linearIdx].pos.xyz;

	//Calculate normal
	vec3 normal = vec3(0.0);
	vec3 a, b, c;
	if (globalIdx.y > 0) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx - 1].pos.xyz - position;
			b = verticesIn[linearIdx - particleGridDims.x - 1].pos.xyz - position;
			c = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;
			normal += cross(a, b) + cross(b, c);
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx - particleGridDims.x].pos.xyz - position;
			b = verticesIn[linearIdx - particleGridDims.x + 1].pos.xyz - position;
			c = verticesIn[linearIdx + 1].pos.xyz - position;
			normal += cross(a, b) + cross(b, c);
		}
	}
	if (globalIdx.y < particleGridDims.y - 1) {
		if (globalIdx.x > 0) {
			a = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;
			b = verticesIn[linearIdx + particleGridDims.x - 1].pos.xyz - position;
			c = verticesIn[linearIdx - 1].pos.xyz - position;
			normal += cross(a, b) + cross(b, c);
		}
		if (globalIdx.x < particleGridDims.x - 1) {
			a = verticesIn[linearIdx + 1].pos.xyz - position;
			b = verticesIn[linearIdx + particleGridDims.x + 1].pos.xyz - position;
			c = verticesIn[linearIdx + particleGridDims.x].pos.xyz - position;
			normal += cross(a, b) + cross(b, c);
		}
	}

	verticesOut[linearIdx].normal = vec4(normalize(normal), 0.0f);
}

void main() 
{
	uvec3 particleGridDims = uvec3(gridDims.x, gridDims.y, 1);
	uvec3 globalIdx = gl_GlobalInvocationID; 
	uint linearIdx = globalIdx.x + (globalIdx.y * particleGridDims.x);
	
	// Safety check
	if (globalIdx.x >= particleGridDims.x || globalIdx.y >= particleGridDims.y) 
		return;

	// Keep pinned particles fixed
	if (IsPinned(linearIdx)) {
		verticesOut[linearIdx].pos = verticesIn[linearIdx].pos;
		verticesOut[linearIdx].vel = vec4(0.0);
		return;
	}

	vec3 position = verticesIn[linearIdx].pos.xyz;
	vec3 oldPosition = verticesIn[linearIdx].oldPos.xyz;
	vec3 velocity = verticesIn[linearIdx].vel.xyz;

	float correctionDamp = .25f;
	vec3 correction = vec3(0,0,0);
	correction = ComputeTotalCorrection(linearIdx, particleGridDims, globalIdx) * correctionDamp;

	correction += ComputeSelfCollision(linearIdx, particleGridDims, restLenHV);

	vec3 correctedPosition = position + correction;

	// Update derivatives
	vec3 correctedVelocity = (correctedPosition - oldPosition) / deltaTime;

	//Update pos on buffer
	verticesOut[linearIdx].pos = vec4(correctedPosition, 1.0);
	verticesOut[linearIdx].oldPos = vec4(oldPosition, 1.0);
	verticesOut[linearIdx].vel = vec4(correctedVelocity, 0.0);

	UpdateNormals(linearIdx, particleGridDims, globalIdx);
}