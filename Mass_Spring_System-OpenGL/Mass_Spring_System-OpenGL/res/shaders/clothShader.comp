#version 460

//Worksize
layout ( local_size_x = 10, local_size_y = 10, local_size_z = 1 ) in;

struct Vertex {
    vec4 pos;
	vec4 vel;
	vec4 color;
	vec4 normal;
	vec4 oldPos;
	vec4 pinned;
};

layout ( std430, binding = 0 ) buffer VertexBufferIn {
	Vertex verticesIn[];
};
layout ( std430, binding = 1 ) buffer VertexBufferOut {
	Vertex verticesOut[];
};

uniform float elasticStiffness=2000;
uniform float deltaTime=0.016;
uniform float restLenHorizontal=0.5;
uniform float restLenVertical=0.5;
uniform float restLenDiagonal=0.707;
uniform float particleMass=100;
uniform float damping=0.02;
uniform vec4 gravityAcceleration=vec4(0,-9.81,0,1);

//A should be the particle, B the neighbour
vec3 elasticForce ( vec3 particlePosition, vec3 otherPosition, float restLength ) 
{
	vec3 dist = otherPosition - particlePosition;
	return normalize(dist) * elasticStiffness * (length(dist) - restLength);
}

void eulerIntegrator ( uint idx, vec3 acceleration, vec3 velocity, vec3 position ) {
	verticesOut[idx].pos = vec4(position + (velocity * deltaTime) + (0.5 * acceleration * deltaTime * deltaTime), 1.0);

	verticesOut[idx].vel = vec4( velocity + (acceleration * deltaTime), 0.0);
}

void verletIntegrator (uint idx, vec3 acceleration, vec3 position, vec3 oldPosition ) {
	vec3 deltaAcceleration = acceleration * deltaTime * deltaTime;
	vec3 deltaPosition = (position - oldPosition) * damping;

	vec3 nextPosition =	position + deltaPosition + deltaAcceleration;

	verticesOut[idx].oldPos=verticesOut[idx].pos;
	verticesOut[idx].pos=vec4(nextPosition,1.0);

	verticesOut[idx].vel = vec4(((nextPosition - position) / deltaTime),0.0);
}

void main() 
{
	uvec3 nParticles = gl_NumWorkGroups * gl_WorkGroupSize;
	uvec3 id = gl_GlobalInvocationID; 
	uint index =  id.x + (id.y * nParticles.x);
	
	if (index > nParticles.x * nParticles.y) 
		return;

	vec3 gravityForce = gravityAcceleration.xyz * particleMass;

	if (verticesIn[index].pinned.x >= 0.5) {
		
		verticesOut[index].pos = verticesIn[index].pos;
		verticesOut[index].vel = vec4(0.0);
		return;
	}
	
	vec3 totalForce=vec3(0,0,0);
	totalForce += gravityForce;

	vec3 position=verticesIn[index].pos.xyz;
	vec3 oldPosition=verticesIn[index].oldPos.xyz;
	vec3 velocity=verticesIn[index].vel.xyz;

	// upper
	if (id.y < nParticles.y - 1) {
		totalForce += elasticForce(position, verticesIn[index + nParticles.x].pos.xyz, restLenVertical);
	} 

	// lower
	if (id.y > 0) {
		totalForce += elasticForce(position, verticesIn[index - nParticles.x].pos.xyz, restLenVertical);
	}
	
	// left
	if (id.x > 0) {
		totalForce += elasticForce(position, verticesIn[index-1].pos.xyz, restLenHorizontal);
	} 
	// right
	if (id.x < nParticles.x - 1) {
		totalForce += elasticForce(position, verticesIn[index + 1].pos.xyz, restLenHorizontal);
	}

	// upper-left
	if ((id.x > 0) && (id.y < nParticles.y - 1)) {
		totalForce += elasticForce(position, verticesIn[index + nParticles.x - 1].pos.xyz, restLenDiagonal);
	}
	// lower-left
	if ((id.x > 0) && (id.y > 0)) {
		totalForce += elasticForce(position, verticesIn[index - nParticles.x - 1].pos.xyz, restLenDiagonal);
	}
	// upper-right
	if ((id.x < nParticles.x - 1) && (id.y < nParticles.y - 1)) {
		totalForce += elasticForce(position, verticesIn[index + nParticles.x + 1].pos.xyz, restLenDiagonal);
	}
	// lower-right
	if ((id.x < nParticles.x - 1) && (id.y > 0)) {
		totalForce += elasticForce(position, verticesIn[index - nParticles.x + 1].pos.xyz, restLenDiagonal);
	}
	
/*	
*/
	totalForce += (-damping * velocity);

	vec3 acceleration = totalForce / particleMass;

	eulerIntegrator(index, acceleration, velocity, position);
	//verletIntegrator(index, acceleration, position, oldPosition);
}